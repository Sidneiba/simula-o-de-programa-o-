// spu-universe/engine.js
import readline from 'readline';
import { VirtualMemory } from './core/VirtualMemory.js';
import { LibraryManager } from './libs/LibraryManager.js';
import CrossLanguageBridge from './core/CrossLanguageBridge.js';
import BridgeBackupManager from './core/BridgeBackupManager.js';

class SPUEngine {
    constructor() {
        this.memory = new VirtualMemory();
        this.libraryManager = new LibraryManager();
        this.bridge = new CrossLanguageBridge();
        this.backupManager = new BridgeBackupManager(this.bridge);
        this.commands = new Map();
        this.setupBridgeCommands();
    }

    setupBridgeCommands() {
        this.commands.set('bridge-stats', this.bridgeStats.bind(this));
        this.commands.set('bridge-clear', this.bridgeClear.bind(this));
        this.commands.set('bridge-remove', this.bridgeRemove.bind(this));
        this.commands.set('bridge-save', this.bridgeSave.bind(this));
        this.commands.set('bridge-backup', this.bridgeBackup.bind(this));
        this.commands.set('bridge-restore', this.bridgeRestore.bind(this));
        this.commands.set('bridge-list-backups', this.bridgeListBackups.bind(this));
    }

    async runCommand(cmd) {
        console.log('üß† Interpretando comando:', cmd);
        const [command, ...args] = cmd.trim().split(' ');

        try {
            switch (command) {
                case 'load':
                    const lib = args[0];
                    if (!lib) {
                        console.log('üìù Uso: load nome_da_biblioteca');
                        return;
                    }
                    await this.libraryManager.loadLibrary(lib);
                    console.log(`‚úÖ Biblioteca '${lib}' carregada com sucesso`);
                    break;

                case 'status':
                    console.log(this.memory.status());
                    break;

                case 'simular':
                    await this.simular(args.join(' '));
                    break;

                default:
                    if (this.commands.has(command)) {
                        await this.commands.get(command)(args.join(' '));
                    } else {
                        console.log('‚öôÔ∏è Comando n√£o reconhecido:', cmd);
                    }
            }
        } catch (error) {
            console.error(`‚ùå Erro ao executar comando '${cmd}':`, error.message);
        }
    }

    async simular(code) {
        console.log('üîç Simulando c√≥digo:', code);
        const actions = this.parseCodeToActions(code);
        for (const action of actions) {
            await this.executeUniversalAction(action, action.lang || 'javascript');
        }
    }

    parseCodeToActions(code) {
        const lines = code.split('\n').map(line => line.trim()).filter(line => line);
        const actions = [];

        for (const line of lines) {
            if (line.startsWith('def ')) {
                const [_, name, params] = line.match(/def (\w+)\((.*?)\):/) || [];
                if (name) {
                    actions.push({
                        type: 'function_definition',
                        details: { name, params: params.split(',').map(p => p.trim()), function: name },
                        lang: 'python'
                    });
                }
            } else if (line.startsWith('return ')) {
                actions.push({
                    type: 'return',
                    details: { value: line.replace('return ', '').trim() },
                    lang: 'python'
                });
            } else if (line.includes('=')) {
                const [variable, value] = line.split('=').map(part => part.trim());
                actions.push({
                    type: 'assignment',
                    details: { variable, value },
                    lang: 'python'
                });
            } else if (line.includes('(')) {
                const [_, func, args] = line.match(/(\w+)\((.*?)\)/) || [];
                if (func) {
                    actions.push({
                        type: 'call',
                        details: { function: func, args: args.split(',').map(arg => arg.trim()) },
                        lang: 'javascript'
                    });
                }
            }
        }
        return actions;
    }

    async executeUniversalAction(action, lang) {
        try {
            switch (action.type) {
                case 'function_definition':
                    await this.bridge.registerFunction(action.details.name, {
                        lang,
                        params: action.details.params,
                        bodyActions: []
                    });
                    console.log(`‚úÖ Fun√ß√£o '${action.details.name}' registrada (${lang})`);
                    break;

                case 'assignment':
                    console.log(`   üî∏ ATRIBUINDO: ${action.details.variable} = ${action.details.value}`);
                    this.memory.setVariable(action.details.variable, action.details.value);
                    break;

                case 'call':
                    console.log(`   üî∏ EXECUTANDO: ${action.details.function}(${action.details.args.join(', ')})`);
                    const libName = action.details.function.split('.')[0];
                    const imports = this.libraryManager.getLoadedLibraries() || [];
                    
                    if (imports.includes(libName)) {
                        const lib = this.libraryManager.getLibrary(lang, libName);
                        const method = action.details.function.split('.')[1];
                        
                        if (lib && lib[method]) {
                            const result = await lib[method](...action.details.args);
                            console.log(`      üìä Resultado: ${JSON.stringify(result).slice(0, 100)}`);
                        }
                    } else if (this.bridge.hasFunction(action.details.function)) {
                        try {
                            const result = await this.bridge.callFunction(action.details.function, action.details.args);
                            console.log(`      üåâ Resultado Cross-Language: ${JSON.stringify(result)}`);
                        } catch (error) {
                            console.log(`      ‚ö†Ô∏è Erro no bridge: ${error.message}`);
                        }
                    } else if (action.details.function === 'print' || action.details.function === 'console.log') {
                        console.log(`      üñ®Ô∏è SA√çDA: ${action.details.args[0]}`);
                    } else {
                        console.log(`      ‚ö†Ô∏è Fun√ß√£o '${action.details.function}' n√£o encontrada`);
                    }
                    break;

                case 'return':
                    console.log(`   üî∏ RETORNANDO: ${action.details.value}`);
                    break;

                default:
                    console.log(`   üî∏ A√ß√£o desconhecida: ${JSON.stringify(action)}`);
            }
        } catch (error) {
            console.error(`‚ùå Erro ao executar a√ß√£o: ${error.message}`);
        }
    }

    async bridgeStats() {
        const stats = this.bridge.getStats();
        
        console.log('\nüìä ESTAT√çSTICAS DO BRIDGE CROSS-LANGUAGE');
        console.log('='.repeat(50));
        console.log(`üìö Total de Fun√ß√µes: ${stats.totalFunctions}`);
        
        console.log('\nüåê Por Linguagem:');
        for (const [lang, count] of Object.entries(stats.byLanguage)) {
            console.log(`   ${lang}: ${count} fun√ß√µes`);
        }
        
        console.log('\nüèÜ Fun√ß√µes Mais Chamadas:');
        stats.mostCalled.slice(0, 5).forEach((func, index) => {
            console.log(`   ${index + 1}. ${func.name} (${func.lang}): ${func.calls} chamadas`);
        });
    }

    async bridgeClear() {
        console.log('‚ö†Ô∏è Tem certeza que deseja limpar TODAS as fun√ß√µes do bridge?');
        console.log('   Digite "CONFIRMAR" para prosseguir:');
        
        return new Promise((resolve) => {
            rl.question('> ', async (answer) => {
                if (answer === 'CONFIRMAR') {
                    try {
                        const count = await this.bridge.clearRegistry();
                        console.log(`‚úÖ ${count} fun√ß√µes removidas do bridge`);
                    } catch (error) {
                        console.error('‚ùå Erro ao limpar o bridge:', error.message);
                    }
                } else {
                    console.log('‚ùå Opera√ß√£o cancelada');
                }
                resolve();
            });
        });
    }

    async bridgeRemove(funcName) {
        if (!funcName) {
            console.log('üìù Uso: bridge-remove nome_da_funcao');
            return;
        }
        
        const removed = await this.bridge.unregisterFunction(funcName);
        if (removed) {
            console.log(`‚úÖ Fun√ß√£o '${funcName}' removida do bridge`);
        } else {
            console.log(`‚ùå Fun√ß√£o '${funcName}' n√£o encontrada`);
        }
    }

    async bridgeSave() {
        await this.bridge.saveToStorage();
        console.log('‚úÖ Estado do bridge salvo persistentemente');
    }

    async bridgeBackup(backupName) {
        const name = backupName || `manual_${Date.now()}`;
        await this.backupManager.createBackup(name);
    }

    async bridgeRestore(backupName) {
        if (!backupName) {
            console.log('üìù Uso: bridge-restore nome_do_backup');
            return;
        }
        
        await this.backupManager.restoreBackup(backupName);
    }

    async bridgeListBackups() {
        const backups = await this.backupManager.listBackups();
        
        console.log('\nüíæ BACKUPS DISPON√çVEIS:');
        console.log('='.repeat(50));
        
        if (backups.length === 0) {
            console.log('   Nenhum backup encontrado');
            return;
        }
        
        backups.forEach((backup, index) => {
            console.log(`${index + 1}. ${backup.name}`);
            console.log(`   üìÖ ${backup.created.toLocaleString()}`);
            console.log(`   üìä ${Math.round(backup.size / 1024)} KB\n`);
        });
    }
}

// engine.js
import readline from 'readline';

// --- Classe principal ---
class SPUEngine {
    constructor() {
        console.log('üß† SPUEngine inicializado');
        // ... (resto do construtor e m√©todos)
    }

    async runCommand(cmd) {
        console.log(`üîß Executando comando: ${cmd}`);
        // ... (c√≥digo do m√©todo)
    }
}

// --- Exporta√ß√£o da classe ---
export { SPUEngine };

// --- Interface de linha de comando (CLI) ---
const SPU = new SPUEngine();
console.log('üöÄ SPU iniciado. Digite comandos para simular programa√ß√£o.');

const rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout
});

async function prompt() {
    rl.question('SPU> ', async (input) => {
        await SPU.runCommand(input);
        prompt();
    });
}

prompt();
